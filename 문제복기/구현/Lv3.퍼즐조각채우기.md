# [Lv3.퍼즐조각채우기](https://school.programmers.co.kr/learn/courses/30/lessons/84021)

## Intro

문제를 잘못읽어서 하루종일 끙끙됐는데,, 마지막에 문제를 다시 읽고보니 허망했다.

문제에는 아래와 같은 제약이 있었는데, 이러한 제약은 오히려 풀이를 쉽게 해주는 좋은 제약인데, 이부분을 내가 잘못 해석했다.

```
게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다.
```

'나는 빈공간보다 작은 퍼즐조각을 여러개 붙여서 해당 공간을 꽉채우는것은 가능하다.' 라고 해석을했는데, 그게 아니었다.

친절히도 예제케이스를 붙여가며 설명까지 해줬는데 이 설명을 제대로 읽지 않았다..


![image](https://github.com/gomudayya/AlgorithmNote/assets/129571789/3c41e9a9-c9b2-47a5-9b90-4d726d61ec44)


나는 여기서 두 번째 설명인 `5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다.` 만 읽고, 

아하! 4번 3번처럼 같이 붙여서 space를 이루는것은 가능하겠구나! 라고 넘겨짚었다.

가장 중요한 설명인 `3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다.` 를 읽지 않은 것이다.

<br>

이렇게 문제를 잘못해석하고나니,, 문제 난이도가 극상이었다.. 안 그래도 쉽지 않은문제였는데 ㅋㅋㅋ

조각을 붙여넣는 경우의수까지 탐색을 하기 위해서 

1. 빈 공간에 조각을 채워넣을 수 있으면 채워넣기.

2. 재귀함수로 dfs 탐색

3. answer값 갱신

4. 백트래킹으로다시 조각을 채워넣기 이전상태로

이런식으로 경우의 수까지 전부 탐색하는 코드를 작성했다. 

얼추 돌아가는 코드가 작성이 되긴 했는데, 효율성에서 터져버렸다. ㅋㅋㅋㅋ 

## 올바른 접근

사실 아래 조건 때문에 문제 풀이 프로세스는 꽤나 간단해졌다.

```
게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다.
```

그냥 gameBoard에서는 빈공간을 추출하고, table에서는 퍼즐조각들을 추출해서 

2중 for문을 돌면서 빈공간에 퍼즐조각을 얼마나 끼워넣을 수 있는지 계산하면 된다. (중간에 회전도 해주면서)



### 퍼즐조각, 빈공간 추출방식

문제조건에서 `퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.`

라는조건이 있었는데, 이 덕분에 퍼즐조각의 형태를 6x6 배열 형태안에서 전부 특정지을 수 있다.

나 같은 경우에는 dfs를 통해서 퍼즐조각을 탐색하면서, 해당 퍼즐조각이 있던곳을 shape배열에 복사했다.

그리고 이 복사된 shape배열에 있는 도형을 왼쪽 위로 밀어버면서 6x6배열로 축소시켰다.

### 퍼즐조각 회전방식

## 교훈

**문제를 풀다가 이게 아닌것 같다 싶으면 문제를 다시 읽어보자.. 넘겨짚지 말고, 한 글자도 남김없이**

## 코드

```java

```
