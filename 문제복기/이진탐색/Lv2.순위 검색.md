# [순위 검색](https://school.programmers.co.kr/learn/courses/30/lessons/72412?language=java)

이진탐색, 해시를 이용한 전처리, 문자열 파싱, 재귀(dfs) 등 할게 많았던 문제

카카오 문제들은 한 문제 안에서 이렇게 다양한것들을 구현하도록 요구하는 것 같다.

다른 부분은 괜찮았는데, 이진탐색(lowerBound) 코드를 작성하는데 시간이 꽤 오래걸렸다. 

이진탐색 문제를 적게풀어서 그런지 아직 조금 부족한감이 있다.

### 문제 풀면서 한 생각

- 쿼리문에 (특정 점수) 이상을 구해야하는데 점수에대한 부분은 이진탐색을 이용하면 좋을 것 같다고 생각

- 나머지 조건이 여러개있는데, 특히 (-) 를 어떻게 처리할지 애매했음

- 구체적으로 생각해서 [java, backend, junior, pizza] 같은 경우가 있으면

  얘는 [-, backend, junior, pizza] [-, -, junior, pizza] 와 같은 조건에서도 검색이 되어야함.

  경우의수를 생각해보면 하나의 Info당 검색되는 조건이 16개가 생기고, 이를 dfs로 구현하면 됨.

  dfs를 조금 망설이면서 쓴것이 아쉽.

- 이렇게 조건별로 Map에 한 번 저장해 놓으면, 쿼리문에대한 검색이 O(1)에 끝나고, Scroe 이분탐색하는 시간밖에 안걸림.

### 실수한 것

- Map에 Score 리스트를 저장해놓고, 정렬을 해놓지 않음. 이분탐색을 쓰려면 정렬과 꼭 함께라는것을 기억하자.

- 정렬 해놓지않은것을 알아차리고, 마저 정렬을 했는데 정렬하는 위치가 잘못 됨.

   - 원래는 Map에 저장을 완료했으면 이후에 리스트들을 한 번만 정렬을 해주면 된다.
   
   - **그런데 별다른 생각 없이, 쿼리문이 한번 들어올때 마다 정렬을 하는식으로 했다.**
 
   - **정렬을 해주는 타이밍도 주의해야한다***. **정렬의 시간복잡도는 O(n log n)이고, 마냥 작지는 않은 시간복잡도이다.**


## 이진탐색 복습

### lowerBound , upperBound

lowerBound와 upperBound가 의미하는것이 무엇인지를 확실히 알고있어야 한다.

**lowerBound -> 정렬을 깨지 않고, target을 삽입할 수 있는 인덱스중 가장 작은 값.**

**upperBound -> 정렬을 깨지 않고, target을 삽입할 수 있는 인덱스중 가장 큰 값.**

이 두개를 이용하면 특정 값 이상(초과)인 것의 갯수가 몇 개 인지

혹은 특정 값 이하(미만)인 것의 갯수가 몇 개 인지를 빠르게 구할 수 있다.

### 구현

이게 막상 구현하려고 하면 조금 헷갈려서, 익숙해질 때 까지는 종이에 예시를 두개정도 써놓고 구현하는게 좋은 것 같다.

구현하는데 있어 몇가지 주의할 점이 있다.

- 일반 이진탐색과 달리 **Bound의 **첫 탐색 범위는 0부터 len 까지**이다.

   - target을 삽입하는 개념이기 때문에 가장 끝에 삽입하려면 len도 탐색범위에 포함시켜야 한다.

   - `int lt = 0, rt = list.size();` 

- while문의 조건은 (lt < rt) 이다.

  - 보통 단순히 탐색만하는 while문의 조건은 (lt <= rt)로 작성한다.
 
  - 이 방식은 탐색범위가 단 하나만 남았을 때 while문을 벗어난다.

- 마지막에 `return` 하는것은 lt나 rt이다. **하지만 그냥 lt를 return하는 것으로 하자**

  - 이 경우 탐색 범위가 단 하나남았을 때 while문을 벗어나고, 그 하나 남아있었던 인덱스를 return 하는 방식이다.
 
    따라서 lt와 rt 둘다 return해도 된다.

  - 하지만 이진탐색문제를 응용하다 보면 `rt = mid-1`로 작성할 때도 있다.
  
    이 때 탐색범위가 [0,1] 이라고 하면 mid가 0이되고, 그 다음 rt는 -1이 된다. 이상황에서 rt를 return하는것은 에러이다.

  - `lt = mid+1` 과 같이 작성해도 lt를 return한다면 괜찮다. 왜냐하면 2개남았을 때 mid가 왼쪽값이기 때문.
 
     mid+1 이라고 해도 탐색범위를 벗어나는일이 없다.
 
- 탐색 범위를 좁힐 때 중요한것이 mid를 포함시키냐 안시키냐인데, 이것은 종이에 써놓고 판단하는게 편하다.

   - lowerBound같은 경우에는 1, 3, 5, 6 에서 2(tagret)를 삽입한다고 하면 3이 있는자리(index:1)에 넣어야한다.
 
   - 따라서 target이 미드보다 작다면, 왼쪽을 보되, mid도 포함시켜야 한다. (rt = mid)
 
   - 1, 2, 2, 2, 5, 6에 2를 삽입한다고 하면 (index:1)에 넣어야 한다.
 
   - 따라서 target이 미드와 같다면 왼쪽을 보되, mid도 포함시켜야 한다. (rt = mid)
 
   - 1과 같은 target이 미드보다 큰 자리에는 삽입할 수가 없다. 따라서 target이 미드보다 크다면 탐색범위에서 제외시키고 오른쪽을 본다. (lt = mid + 1)

- 좀 편하게 정리하면 아래와 같다.

   - lowerBound, upperBound 둘 다 target이 mid보다 작을 때에는 mid를 포함시킨다(rt = mid).

   - target이 mid보다 클 때에는 mid를 포함시키지 않는다. (lt = mid+1)
 
   - 다만 같을 때가 차이가 나는데 lowerBound는 target이 mid와 같을 때 포함시키고, upperBound는 target이 mid와 같을 때 포함시키지 않는다.


### 코드

```java
int lowerBound(List<Integer> scores, int target) {
        int lt = 0, mid = 0, rt = scores.size();
        
        while (lt < rt) {
            mid = (lt + rt) / 2;
            if (target <= scores.get(mid)) {
                rt = mid;
            } else {
                lt = mid+1;
            }
        }
        
        return rt;
    }
```
