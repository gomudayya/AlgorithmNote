# [Lv4. 징검다리](https://school.programmers.co.kr/learn/courses/30/lessons/43236)

## Intro

개인적으로 정말 어려웠던 문제 였고, 문제 해설을 봐도 이해가 안되었던 문제였다.

여러번 문제를 분석해보고 정리해본 시도끝에 어느정도 이해한 것 같다.

## 접근방식

### 1. 완전 탐색을 돌수있나?

문제에서 묻고있는 것은

```
바위를 제거하는 경우의수가 여러가지가 있을텐데, 

이중에서 바위를 어떻게 없애야 바위사이의 거리의 최솟값이 최대가 되는가? 그리고 그 최솟값의 값은 얼마인가? 이다.
```

우선은 완전탐색을 떠올려볼만 하다. 바위를 없애는 모든 경우의수를 탐색하고, 그 때마다 최솟값을 확인해주면 된다.

하지만 바위의 개수의 범위는 5만, n의 범위도 5만이하. 50000C25000의 조합수가 나온다. 따라서 불가능하다.

### 2. 바위를 어떤식으로 없애야 할까?

바위사이의 거리들의 최솟값이 최대가 되려면 어떻개 해야할까?

가장 짧은 거리가 나타나는 바위사이를 조정해주면 된다.

아래의 예제케이스를 보면...

돌위치 | 3 | 7 | 8 | 10 | 13
|--|--|--|--|--|--|
거리 | 3 | 4 | 1 | 2 | 3 | 

돌(7)과 돌(8)사이의 거리가 1이다.

그러면 이 때 돌(7)과 돌(8)중 하나를 없애주면 된다. 그리고 이런식으로 거리의 최솟값을 찾고, 그 최솟값에 걸려있는 돌을 없애는 것이다.

그런데 **문제는 이 때 앞에있는 돌을 없앨지, 뒤에있는 돌을 없앨지 판단이 불가능하다는 것**이다.

어떤돌을 없애야 추후에 최선의 판단이 될 수 있었을지? 이것을 판단할 수가 없다. 

결국 앞 돌을 없애야할지, 뒷 돌 없애야할지 완전탐색이라도 돌아야 할 것 같은데 이 조차도 시간복잡도가 여의치 않다.

### 3. 그러면 어떻게 해야되는데요

모르겠다.. 모르니까 못풀었지.. 

그 다음 발상을 떠올리기가 정말 어려운 것 같은데, 아래와 같은 아이디어를 생각을 한 번 해봐야 한다. 

파라매트릭서치에서 쓰이는 아이디어이다. [참고 : 비슷한 문제](https://github.com/gomudayya/AlgorithmNote/blob/main/%EB%AC%B8%EC%A0%9C%EB%B3%B5%EA%B8%B0/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/Lv3.%EC%9E%85%EA%B5%AD%20%EC%8B%AC%EC%82%AC.md)

**비록 정답값을 한 번에 구할 수는 없지만, 해당 값이 정답일지 아닐지는 판단할 수 있는가?**

**만약 그것이 가능하다면 정답값을 여러 번, 넣어가면서 판정해보는것은 어떤가?**

**이 때, 이진탐색을 통해서 시간복잡도를 줄여볼 수는 없을까?**

이 문제에는 과연 어떨까.

예제케이스를 한번 보자

**N = 2**

돌위치 | 5 | 11 | 14 | 17 | 21 | 25
|--|--|--|--|--|--|--|
거리 | 5 | 6 | 3 | 3 | 4 | 4 |

이 경우 4가 정답이 될 수 있을까?

즉 다시말하면, 돌을 두 번 없애서 최소거리를 4로 만들 수 있을까?

이것에 대해서는 판정할 수 있다. 

**앞에서부터 돌을 순회하면서 돌 사이의 거리가 4보다 작은값이 나올 때 (arr[i+1] - arr[i] < 4) 
뒤에있는 돌(i+1)을 없애는 것이다.** 

하지만 이 때 실제 없애는 연산은 번거롭고, 시간복잡도도 높아질 우려가 있기 때문에, 

돌 사이의 거리가 4보다 작은값이 몇번 나오는지 count하는 것이다. 

그리고 이 값이 N보다 크게된다면 정답이 될 수 없고, 이 값이 N이하인 값이 나온다면 정답이 된다.

여기에 이제 이진탐색까지 곁들여서 정답값의 후보들을 넣어가며 판정해보면, 시간복잡도도 챙길 수 있는것이다.

### 구현 주의사항

여기에서 돌을 없애면은 돌을 없앤것을 감안하고, 다시 거리를 계산해야한다.

돌위치 | 5 | 11 | 14 | 17 | 21 | 25
|--|--|--|--|--|--|--|
거리 | 5 | 6 | 3 | 3 | 4 | 4 |

즉 여기에서 14번 돌을 없앨경우에, 그다음 거리계산은 17-14를 해야하는 것이 아니라 17-11을 해야한다.

이 부분을 유의해서 구현하면 된다.

### 부연설명.

아까 2번에서는, 왜 앞돌을 없앨지 뒷돌을 없앨지 판단을 못했는데 왜 위에서는 뒤엣돌을 없애는식으로 구현하는가?

이것은 최선의 답을 구하는것과, 어떤 값이 정답인지 아닌지 단순히 판정하는 것 사이에서 생긴 미묘한 차이이다.

**앞에 돌을 없애게 된다면 없앤 돌 앞에있는 돌과의 거리가 길어지게 된다.**

**뒷쪽에 있는 돌을 없애게 된다면 없앤 돌 뒤에있는 돌과의 거리가 길어지게 된다.**

**그런데 우리는 for문을 앞에서부터 순회하기 때문에 앞에있는 돌들끼리 계산해서 나온 거리는 4보다 작은것이 확실하다.**

그렇기 때문에 앞에있는 돌을 없앨 필요는 없다. 무조건 뒤에있는 돌을 없애면서 판단하면 된다. 그리디한 판단이 가능해진다.

## 코드

```java
import java.util.*;

class Solution {
    
    public int solution(int distance, int[] rs, int n) {
        Arrays.sort(rs);
        int[] rocks = new int[rs.length+2];
        rocks[rocks.length-1] = distance;
        for (int i = 1; i < rocks.length-1; i++) {
            rocks[i] = rs[i-1];
        }
        
        int lt = 1;
        int rt = distance+1;
        
        while(lt < rt) {
            int mid = (lt+rt)/2;
            if(isValid(mid, rocks, n)) {
                lt = mid+1;
            } else {
                rt = mid;
            }
        }
        
        return lt-1;
    }
    
    boolean isValid(int d, int[] rocks, int n) {
        int count = 0;
        int prev = 0;
        for (int i = 1; i < rocks.length; i++) {
            if (rocks[i] - prev < d) {
                count++;
                continue; // 바위 제거, 이전바위를 그대로
            }
            prev = rocks[i];
        }
        return count <= n;
    }
}
```
