# 재귀함수

함수 안에서 자기 자신을 다시 호출하는 함수를 재귀함수라고 한다.

알고리즘에서는 탑다운DP, 백트래킹, DFS, 분할정복 등등 여러 방식으로 재귀함수를 사용한다.

하지만 재귀라는 굉장히 와닿지 않고, 직관적으로 받아들여지지 않는다. 

개인적으로 재귀를 이해하는데 가장 도움이 됐엇던 말은, 백준 단계별로 풀어보기에서 있었던 것 같은데 (지금은 없는듯..?)

```
너무 깊게 생각하지 마세요.

나머지는 컴퓨터가 알아서 해줄거에요.
```

이 말이었던것 같다. 재귀함수의 흐름을 하나하나 시뮬레이션 하는것도 처음에는 물론 필요하다.

다만 문제를 풀어보면서 가장 크게 느끼는 점은 두가지이다.

- **특정 재귀함수의 호출이 어떠한 일을 하는지 명확하게 정의해야 한다.**

- **'이미 계산되어 있을 것이다!'** 라는 마인드가 필요하다.

## 예시 1. 팩토리얼

```java
public static int f(int n) {
    if (n == 1) return 1;
    return n * f(n-1);
}
```

위의 코드를 예시로 생각해보자. f(n)이 하는 일은 무엇일까? f(n)은 어떻게 정의되는걸까?

**혹은 내가 팩토리얼을 재귀로 구현하는 상황이었다면, f(n)을 어떻게 정의했어야 했을까?**

좀 더 구체적으로 생각해보면?

f(5)는 5 * 4 * 3 * 2 * 1 , 즉 5부터 1까지의 곱이다. 5!

일반화 하면 f(n)은 n*(n-1) * (n-2) ... * 1이다.

점화식으로 적어보면? f(n) = n * f(n-1) 이다.

그렇기 때문에? `return n * f(n-1);` 이라고 적는다.

여기서 f(n-1)을 호출한다는 것에 대해서 당황하지말고, 너무 깊게 생각할필요도 없다. 

우리는 이미 f(n)이 1부터 n까지의 곱이라는것을 **명확하게 정의** 했다. 

그리고 f(n)이 f(n) = n * f(n-1)의 점화식 형태를 가진다는 것도 알 수 있다. 그러면 그냥 그것을 함수에 옮기면 된다.

f(n-1)에 대한 값은 컴퓨터가 알아서 구해줄것이다!

다만 한없이 f(n-1)을 호출할 수는 없으니 종료조건이라는 것을 적어줘야 한다.

그게 `if(n==1) return 1` 이 부분이고, 사실 종료조건을 설정하는 것은 몇번 해보면 되서, 어렵지 않은일이다.

## 재귀의 분류

