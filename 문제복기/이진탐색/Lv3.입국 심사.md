# [입국심사](https://school.programmers.co.kr/learn/courses/30/lessons/43238#)

이진탐색 문제인데, 이런 유형의 문제를 파라매트릭 서치라고 부르는 것 같다.

정렬된 범위 안에 정답이 있을 경우(결정되어 있을경우), 이진탐색을 통해서 정답값을 찾아가면 된다.

사실 처음봤을 때 떠올리기는 쉽지 않은 것 같다. 대신 한 번 기억하면 그 다음부터는 잘 떠올릴 수 있을 것 같다.

## 문제접근

일단 제한사항의 숫자들이 매우크다. 입국 심사를 기다리는 사람이 10억명까지 가능하고, 심사시간 또한 10억분까지 가능하다.

대신 심사관의 수는 최대 10만 밖에 되지 않는다.  

시뮬레이션 돌리듯이 시간변화에 따라 풀었다가는 최악의 경우 10억 * 10억분 까지 for문을 돌려야 한다.

그래서 완전 다른 접근이 필요한데, 이 정도의 입력제한사항이면 이진탐색을 떠올릴 하다. (log n의 굉장히 짧은 알고리즘 이기 때문)

아니면 심사관의 숫자를 n으로잡고 알고리즘을 돌려야 하는데, 이런 방법은 딱히 떠오르지 않는다.

 ## 발상

**N에 따라서 시간을 구하려고 하지말고, 거꾸로 생각해서 시간이 T일때 N은 어떻게 되는가? 를 생각해야 한다.**

예제케이스와 같이 times 배열이 [7, 10] 인 경우에 시간이 28이면 N은 6이다.

생각해보면 N에서 시간을 구하는건 굉장히 어려운데, T에서 N을 구하는건 생각보다 쉽다. 

(28 / 7) + (28 / 10) = 6이기 때문이다. 

이처럼 T에따라서 N은 굉장히 쉽게구할 수 있고, T의 범위는 확정지을 수 있다. (1~10억*10억)

T값만 어떻게어떻게 탐색해서 찾으면 된다.

그런데 이 때 T에따른 N의 값은 서로 비례관계이다. 

T가 커지면 N도 커지고 T가 작아지면 N도 작아진다. 비례or반비례의 경향성이 있으면 이진탐색을 사용하면 된다.

## 구현

이진탐색은 구현할 때 삑사리나기가 굉장히 쉽기 때문에 구체적으로 적어보면서 구현해야한다.

times 배열이 [7,10]일 때 T에따른 N의 분포는 다음과 같다.

T | 26 | 27 | 28 | 29 | 30 |
|--|--|--|--|--|--|
N | 5 | 5 | 6 | 6 | 7 |

우리는 N이 6일때 T에 해당하는 값을 탐색해야 한다.

위의 표를 보면 6이 여러개 나오기 떄문에 **다음 탐색범위에 MidValue가 TargetValue와 같더라도 포함을 시켜아한다.**

그런데 만약 target으로 목표하는 N값이 존재하지 않는다면 어떨까?

times 배열이 [1, 3] 이고 N은 3이라면 어떻게해야할까?

T | 1 | 2 | 3 | 4 | 5 | 6
|--|--|--|--|--|--|--|
N | 1 | 2 | 4 | 5 | 6 | 8

위의 표를보면 N이 3일때가 존재하지 않는다. 

사실 다시 생각해보면 우리는 N에 해당하는 T값을 찾는것이 아니라

**value값이 N이상을 만족하는 T의값중 가장 최솟값을 구하는 것이다.**

따라서 MidValue가 TargetValue보다 같더라도 다음 탐색범위에 포함을 시켜야 한다.

즉 위에서 짚은것들을 한문장으로 정리하면 

**"찾으려는 N값보다 이상이면서, 가장 왼쪽에 있는값을 탐색하면 된다"** (lowerBound)

여기에서 짚은 내용이 이진탐색의 if문 구현을 결정한다.

```java
if (targetValue <= midValue) {
    rt = mid;
} else {
    lt = mid+1;
}
```
## 코드

```java
class Solution {
    public long solution(int n, int[] times) {
        return search(n, times);
    }
    
    long search(int targetValue, int[] times) {
        long lt = 1;
        long rt = 1_000_000_000l * 1_000_000_000l;
        while (lt < rt) {
            long mid = (lt + rt) / 2;
            long midValue = count(mid, times);
            if (targetValue <= midValue) {
                rt = mid;
            } else {
                lt = mid+1;
            }
        }
        return lt;
    }
    
    long count(long minute, int[] times) {
        long res = 0;
        for (int i = 0; i < times.length; i++) {
            res += (minute / times[i]);
        }
        return res;
    }
}
```
