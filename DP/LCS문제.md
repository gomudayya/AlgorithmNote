## 문제 요약

최장 공통 부분 수열의 길이를 구하는 문제.

예를들어

```
ACAYKP
CAPCAK
```

다음과 같은 경우 최장 공통 부분 수열은 `ACAK` 가 되고, 그 길이는 4이다.

## 풀이 방법 / 접근 방법

### 1단계 (테이블 정의)

일단 2차원 DP 테이블을 그려서 아래와 같이 양 사이드에 문자열s1과 문자열s2 를 둘 생각을 해야 한다. 

![image](https://github.com/gomudayya/AlgorithmNote/assets/129571789/0c941d06-8e81-4d85-b245-078fab568f06)

이 **DP테이블의 정의는 DP[i][j] = s1의 i번째 문자열과 s2의 j번째 문자열까지의 최장 공통 부분 수열의 길이** 이다. 

글로 적으려니까 조금 장황하게 표현되는데 곰곰히 조금만 생각해보면 별거 아니다.

**테이블 정의는 문제에서 구하고자 하는값 (최장 공통 부분 수열의 길이) 를 생각해보면, 충분히 정의내릴 수 있다.**

최장 공통 부분 수열의 길이를 구해야하는데, 단지 그것을 step by step 으로 구하자는 소리이다.

### 2단계 (고민하기)

사실 테이블 정의까지는 했는데, 그 다음에 점화식을 어떻게 구해야할지 막막하다.

여기서 점화식을 바로 떠올리는 것은 불가능하다고 생각한다.

"음.. 이거는 점화식이 s[i]와 s[j]가 같을 때에는 MAX(DP[i-1][j], DP[i][j-1])이 되겠군. 그리고 다를 때에는 DP[i-1][j-1] + 1이 되는것 같아."

라고 바로 생각할 수는 없다.

**결국에는 고민을 해야하는 과정**이 필요하고, 이럴때는 부담갖지 말고 **첫번째 줄 부터라도 잘 채워나가볼 생각**을 하자.

(위의 예시 그림 기준)
첫번째 줄을 채우다보면 다음과 같이 생각하게 된다.

"음 G는 ABCDEF에 아에 없으니까 다 0이되네?"

두번째 줄을 채우다보면 다음과 같이 생각하게 된다.

"흠.. dp[2][2] 지점을 채울 때 1이 늘어났는데, 이거는 **s[i]와 s[j]가 일치하게 되면서 1이늘어나네?**"

"s[i]와 s[j]가 일치할 때랑 일치하지 않을때랑 점화식이 다르게 작성되는건가?" (여기까지하면 굿)

"dp[2][3] 지점을 채워야 하는데 생각해보니 dp[2][3]가 dp[2][2]보다 작은것은 불가능하네?"

"**생각해보니 의미적으로도 그렇네?** **AB와 GB의 LCS값보다는 ABC와 GB의 LCS값이 더 크거나 같을수밖에 없네?** 포함되는 개념이니까"

세번째 줄을 채우다보면 다음과 같이 생각하게 된다.

"dp[3][2] 지점을 채워야하는데, 음 생각해보니 이 지점은 B가 있기때문에 1이되네?"

"생각해보니 아까와 같이 **AB와 GB의 LCS값보다는 GBC와 AB의 LCS값이 더 크거나 같을수밖에 없겠네?**"

"dp[3][3] 지점을 채워야하는데 음.. 이거는 BC가 같으니까 2이긴하네? 근데 **아까처럼 s[i]와 s[j]가 일치되면서 뭔가 1이 늘어나는거 같아**"

"그런데 1이 어디에서 늘어나는거지? dp[2][2] 지점에서늘어나는건가? dp[2][3] ? dp[3][2]?"

"생각해보니 AB와 GB의 LCS에서 C라는 일치되는 알파벳이 하나가 딱!!! 추가되면서 +1이 되는것 같은데? dp[2][2]에서 +1을 해주는게 유력한 것 같아"

"dp[2][3]이나 dp[3][2]에서 +1을 하는것은 안되는걸까? 음 안될것같아 이거는 C가 만약에 앞에 2개 3개 나와있는 케이스를 고려하면 이렇게 해선 안돼"

...
...
...

이렇게 차근차근 접근하면 결국 아래와같은 결론에 도달할 수 있다.

"음.. 이거는 점화식이 s[i]와 s[j]가 같을 때에는 MAX(DP[i-1][j], DP[i][j-1])이 되겠군. 그리고 다를 때에는 DP[i-1][j-1] + 1이 되는것 같아."

**마법처럼 보자마자 점화식이 구해지는 일은 없다!! 당장 할 수 있는것 부터 차근차근 고민해보자** 

### 3단계

점화식을 구했으면 이제 코드로 작성하는 일만 남았다.

DP문제는 사실 코드 작성은 쉽다. Skip~~

단 유의할 것은 DP문제는 테이블 사이즈를 N+1로 잡고, 0번째 칸은 무시하고 1번째칸부터 채워나가는것이 편할때가 많다.

이 문제도 그런 케이스다.

### 결론

알고리즘 문제를 풀 때 그냥 단순히 "아 이렇게 푸는거구나" 하고 넘어가서는 안된다고 생각한다.

어떻게 접근했어야 하는지, 생각의 방향을 어떤식으로 잡았어야했는지 복기해보는것이 더 중요하다고 생각한다.

그래서 풀이에 치중하기보다는 과정에 치중해서 정리했는데, 

사실 쓰고보니 당연한 것만 적은것 같기도하다 ㅋㅋ



## 관련 문제

- [백준 9251](https://www.acmicpc.net/problem/9251)

## 참고 자료

- [그림으로 알아보는 LCS 알고리즘](https://velog.io/@emplam27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-LCS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Longest-Common-Substring%EC%99%80-Longest-Common-Subsequence#%EC%B5%9C%EC%9E%A5-%EA%B3%B5%ED%86%B5-%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4longest-common-subsequence-%EA%B8%B8%EC%9D%B4-%EA%B5%AC%ED%95%98%EA%B8%B0)
- 
