# 이진탐색 삑사리 나지않고 구현하기

이진탐색 구현하다보면 삑사리나는 경우가 많이나온다.

while문 안을 못빠져나온다던지, 혹은 lowerBound나 upperBound를 했는데, 필요에따라서 구한값의 -1을 해주어야 할 때도있다.

이런식으로 헷갈리는 포인트들이 많은데 몇가지만 기억하면 시간이 좀 걸리더라도 잘 구현할 수 있다.

## 스타일

그전에 일단 이진탐색 코드를 작성하는 스타일이 조금 다양한 것 같다.

가장 큰 차이는 while 조건을 어떻게 설정하느냐인데, ex) `lt + 1 < rt` , `lt < rt`

일단 나는 while 조건에 `lt < rt` 를 넣어서 작성한다.

## 템플릿

```java

int search(...) {

  int lt = 0;
  int rt = POSSIBLE_MAX;
  
  while (lt < rt) {
    int mid = (lt + rt) / 2;
    if (조건) {
      lt = mid+1;
    } else {
      rt = mid;
    }
  }
  return lt;  // 혹은 경우에 따라 lt-1
}

```

코드를 명확하게 이해하하기 위해선 몇가지 염두해야할것들이 있다. 

- (lt + rt) / 2

  - mid를 구하는 연산인데, **이연산의 특징은 나머지가 0이 아닐때에는 그냥 버림처리를 한다는 것이다.**

  - 위의 이유로 **mid값을 계산할 때, 나머지가 있으면 가운데보다 좌측으로 한 칸 치우쳐서 계산된다.**

loop문을 어떻게 벗어나는지 확인하기 위해 탐색범위가 좁혀져 2개남았을 때를 생각해보자.

이때 각 탐색범위의 분포를 조건을 만족하면 T (true), 조건을 만족하지않으면 F (false)로 표시해보면

4가지 경우의수가 나온다. (TT, TF , FT, FF)

앞서 말했듯이, mid값은 좌측으로 치우쳐서 나오기 때문에, 4가지 경우의수 모두 mid가 왼쪽인 채로 시작한다.

- TT, TF
  
  - 이 경우 왼쪽이 True이므로 `lt = mid + 1`이 된다.
 
  - lt와 rt가 같아지면서 while문을 벗어난다.

- FT

  - 이 경우 `rt = mid` 가 실행된다.
  
  - mid는 왼쪽이었기에 lt와 rt가 같아지면서 while문을 벗어난다.

- FF

  - 이케이스가 나온다면 초기 탐색범위를 잘못잡은 것이다. 찾고자하는 값이 탐색범위안에 존재하지 않는다.
 
  - 특정값이 존재하면 찾고, 존재하지 않으면 -1을 반환해야한다면,
  
    `lowerBound` 코드를 작성하고 반환값이 찾고자하는 값과 일치하는지 확인하면 된다.

### 특징

- 종료시점에 lt와 rt는 항상 같다.

  - 그래서 어떤것을 반환하던 상관이없다. 나는 항상 lt쪽을 반환한다.

- 조건문과 `return`의 형태(lt or lt-1)만 변경하고, 나머지코드는 고정이다. 

- `return`문의 형태가 왜 달라지고, 나머지코드는 왜 고정시켜야 하는지는 아래에서 설명.

## 잘못된 코드 (무한루프가 발생하는 코드)

```java

int search(...) {

  int lt = 0;
  int rt = POSSIBLE_MAX;
  
  while (lt < rt) {
    int mid = (lt + rt) / 2;
    if (조건) {
      lt = mid;
    } else {
      rt = mid-1;
    }
  }
  return lt;  // 혹은 경우에 따라 lt-1
}

```

위의코드는 왜 무한루프 발생할까? 다시한번 탐색범위를 2로 좁혀서 확인해보자. (TT, TF, FT.  FF는 배제) 

마찬가지로 모든케이스는 왼쪽값이 mid가 된다.

- TT, TF

  -  그런데 이 경우 `lt = mid` 가 호출되므로 탐색범위의 변화가 없다. 이때 무한루프가 발생한다.
 
- FT

   - 이 경우 `rt=mid-1` 이 호출된다. rt값이 1작아지면서 lt값과 같아지고, loop를 벗어난다.

여기서 우리가 알수있는 사실은 **무조건 `lt = mid+1` 을 고정시켜야 한다는 것이다.**

`lt = mid+1` 을 고정시키지 않으면 무한루프가 발생한다는 것을 확인하였다. 

## 탐색 분포 확인하기

조건문을 정의하였고, 탐색범위가 조건에 따라서 TTTTTTTTTTTTTTTTFFFFFFFFFF 와 같은 형태로 분포하고 있다고 생각해보자.

이 때 경우에 따라서, 어떤식으로 코드를 작성해야하는지 확인해보자.

경우는 두가지이다. 

### 1. F가 나오는것중에 가장 왼쪽에 있는값을 구하기.

이 경우 mid가 T이면 **탐색범위에서 배제(즉 `lt = mid+1`)** 하는식으로 코드를 작성하면 된다.

아래와 같이 작성된다.
```java
int search(...) {

  int lt = 0;
  int rt = POSSIBLE_MAX;
  
  while (lt < rt) {
    int mid = (lt + rt) / 2;
    if (조건) {
      lt = mid+1;
    } else {
      rt = mid;
    }
  }
  return lt;
}
```


### 2. T가 나오는것중에 가장 오른쪽에 있는값을 구하기. (주의)

이 경우 T이면 탐색범위에서 포함(`lt = mid`)하고, F이면 탐색범위에서 배제(`rt = mid-1`)하면 된다.

**라고 생각하기 쉽다!!!**

하지만 위에서 

**잘못된 코드를 살펴볼 때 `lt = mid+1`을 고정시키지 않으면 무한루프가 발생한다는 것을 확인했다.**

따라서 위와같은 방식으로 코드를 작성하면 무한루프의 늪에 빠지게 된다.

그러면 어떻게 해야하는가? **1번 방식처럼 코드를 작성하고, lt값을 -1해서 return 해주면된다.**

```java
int search(...) {

  int lt = 0;
  int rt = POSSIBLE_MAX;
  
  while (lt < rt) {
    int mid = (lt + rt) / 2;
    if (조건) {
      lt = mid+1;
    } else {
      rt = mid;
    }
  }
  return lt-1;
}
```



## 주의사항

- 초기 `rt`값을 넉넉하게 잡자. **그 이유는 `return` 문에서 lt-1을 할경우에는 원래 내가 생각했던 범위에 +1을 해야한다.**

- 그냥 범위를 타이트하게 잡지말고, 처음부터 비교적 넉넉하게 잡아서 엣지케이스를 처리하자. log n 알고리즘은 빠르니까.



